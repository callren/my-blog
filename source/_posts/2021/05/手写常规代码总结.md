---
title: 手写常规代码总结
date: 2021-05-24 20:50:37
tags: 面试
categories: 面试
---

## 手写 call

```JavaScript
// func.call(this, a, b)
Object.prototype._call = function(context, ...params){
    if(typeof this !== 'function'){
        throw TypeError('type is fail')
    }
    let that = context || window
    let symbol = Symbol('func')
    that[symbol] = this
    let result = that[symbol](...params)
    delete that[symbol]
    return result
}
```

## 手写 apply

```JavaScript
// func.apply(this, [a, b])
Object.prototype._apply = function(context, params = []){
    if(typeof this !== 'function'){
        throw TypeError('type is fail')
    }
    let that = context || window
    let symbol = Symbol('func')
    that[symbol] = this
    let result = that[symbol](...params)
    delete that[symbol]
    return result
}
```

## 手写 bind

```JavaScript
// func.bind(this, a, b)
Object.prototype._bind = function(context, ...params1){
    if(typeof this !== 'function'){
        throw TypeError('type is fail')
    }
    let that = context || window
    return (...params2) => {
        this.call(that, ...params1,)
    }
}
```

## 手写 instanceof

```JavaScript
function instanceof(L, R){
    let l = L._proto_
    let r = R.prototype
    while(true){
        if(l === null) return false
        if(l === r) return true
        l = l._proto_
    }
}
```

## Object.create

```JavaScript
function create(obj) {
    function F() {}
    F.prototype = obj
    return new F()
}
```

## promise

```JavaScript
class Promise {
  constructor(executor) {
    ...
    // 初始化
    ...
   this.onFulfilledCbs = []; // 成功回调函数队列
   this.onRejectedCbs = []; // 失败回调函数队列
    ...
  }

  resolve(val) {
    if (this.status === PENDING) {
      ...
      // 一旦状态改变，遍历函数队列将终值作为形参触发队列中的函数
     this.onFulfilledCbs.forEach(fn => fn(this.value));
    }
  }

  reject(err) {
    if (this.status === PENDING) {
      ...
     this.onRejectedCbs.forEach(fn => fn(this.reason));
    }
  }

  then(onFulfilled, onRejected) {
    ...
    // 当状态处于pending时
   if (this.status === PENDING) {
     // 向函数队列添加微任务回调函数
     this.onFulfilledCbs.push(value => {
       setTimeout(() => {
         try {
           onFulfilled(value)
         } catch (e) { reject(e) }
       })
     });

     this.onRejectedCbs.push((reason) => {
       setTimeout(() => {
         try {
           onRejected(reason)
         } catch (e) { reject(e) }
       })
     });
   }
  }
}
```

promise.all 以及 promise.race 两方面可以 forEach，如果是 all 的情况，values 看是否达到了数组，race 则直接 resove 外围的 promise

## new 模拟

```JavaScript
function newOperator(ctor) {
    if (typeof ctor !== 'function'){
        throw 'newOperator function the first param must be a function';
    }

    var args = Array.prototype.slice.call(arguments, 1);
    // 1.创建一个空的简单JavaScript对象（即{}）
    var obj = {};
    // 2.链接该新创建的对象（即设置该对象的__proto__）到该函数的原型对象prototype上
    obj.__proto__ = ctor.prototype;
    // 3.将步骤1新创建的对象作为this的上下文
    var result = ctor.apply(obj, args);
    // 4.如果该函数没有返回对象，则返回新创建的对象

    var isObject = typeof result === 'object' && result !== null;
    var isFunction = typeof result === 'function';
    return isObject || isFunction ? result : obj;
}
```

## 深拷贝
